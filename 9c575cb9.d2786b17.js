(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{109:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),d=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=d(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,b=p["".concat(s,".").concat(u)]||p[u]||h[u]||i;return n?r.a.createElement(b,c(c({ref:t},l),{},{components:n})):r.a.createElement(b,c({ref:t},l))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=u;var c={};for(var o in t)hasOwnProperty.call(t,o)&&(c[o]=t[o]);c.originalType=e,c.mdxType="string"==typeof e?e:a,s[1]=c;for(var l=2;l<i;l++)s[l]=n[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},87:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return d}));var a=n(3),r=n(7),i=(n(0),n(109)),s={id:"tutorials-scene-transitions-updating-scene-class",title:"Updating The Scene Class",hide_title:!1,hide_table_of_contents:!1,sidebar_label:"Updating the Scene Class",custom_edit_url:null,keywords:["monogame tutorial","monogame framework","monogame","tutorial","scene transition","scene","scenes"],description:"A tutorial on create scene transition effects in a MonoGame project.",image:null,slug:"/tutorials/scene-transitions/updating-scene-class"},c={unversionedId:"tutorials/scene-transitions/tutorials-scene-transitions-updating-scene-class",id:"tutorials/scene-transitions/tutorials-scene-transitions-updating-scene-class",isDocsHomePage:!1,title:"Updating The Scene Class",description:"A tutorial on create scene transition effects in a MonoGame project.",source:"@site/docs\\tutorials\\scene-transitions\\updating-scene-class.md",slug:"/tutorials/scene-transitions/updating-scene-class",permalink:"/docs/tutorials/scene-transitions/updating-scene-class",editUrl:null,version:"current",sidebar_label:"Updating the Scene Class",sidebar:"tutorials",previous:{title:"RenderTarget2D Overview",permalink:"/docs/tutorials/scene-transitions/rendertarget-overview"},next:{title:"The Transition Class",permalink:"/docs/tutorials/scene-transitions/transition-class"}},o=[{value:"RenderTarget Property",id:"rendertarget-property",children:[]},{value:"GenerateRenderTarget()",id:"generaterendertarget",children:[]},{value:"HandleGraphicsReset() and HandleGraphicsCreated()",id:"handlegraphicsreset-and-handlegraphicscreated",children:[]},{value:"Using the RenderTarget",id:"using-the-rendertarget",children:[]},{value:"Disposing the RenderTarget",id:"disposing-the-rendertarget",children:[]}],l={rightToc:o};function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"The first thing we're going to do is update our ",Object(i.b)("inlineCode",{parentName:"p"},"Scene")," class.  Each scene will need to have it's own ",Object(i.b)("inlineCode",{parentName:"p"},"RenderTarget2D")," instance that it draws to.  Open the ",Object(i.b)("strong",{parentName:"p"},"Scene.cs")," class file and let's get started."),Object(i.b)("h3",{id:"rendertarget-property"},"RenderTarget Property"),Object(i.b)("p",null,"We need to add new property to the ",Object(i.b)("inlineCode",{parentName:"p"},"Scene")," class to hold our render target instance. To do this, add the following property."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"/// <summary>\n///     Gets the RenderTarget this Scene draws to.\n/// </summary>\npublic RenderTarget2D RenderTarget { get; protected set; }\n")),Object(i.b)("p",null,"This makes it so the render target is publicly accessible for any object that has a reference to our Scene instance, but only Scene types can set the value."),Object(i.b)("h3",{id:"generaterendertarget"},"GenerateRenderTarget()"),Object(i.b)("p",null,"We need to add a new method to our ",Object(i.b)("inlineCode",{parentName:"p"},"Scene")," class that we can use to create the ",Object(i.b)("inlineCode",{parentName:"p"},"RenderTarget2D")," instance.  We could just do this in the constructor of our Scene class, but remember, we may need to recreate the render target if the graphics device resets.  So we'll do it in a method we can call when needed."),Object(i.b)("p",null,"Add the following method to the ",Object(i.b)("inlineCode",{parentName:"p"},"Scene")," class."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"/// <summary>\n///     Generates a RenderTarget2D instance for our Scene.\n/// </summary>\npublic virtual void GenerateRenderTarget()\n{\n    int width = _game.GraphicsDevice.PresentationParameters.BackBufferWidth;\n    int height = _game.GraphicsDevice.PresentationParameters.BackBufferHeight;\n\n    //  If the RenderTarget instance has already been created previously but has yet\n    //  to be disposed of properly, dispose of the instance before setting a new one.\n    if (RenderTarget != null && !RenderTarget.IsDisposed)\n    {\n        RenderTarget.Dispose();\n    }\n\n    RenderTarget = new RenderTarget2D(_game.GraphicsDevice, width, height);\n}\n")),Object(i.b)("p",null,"This method will check to see if there is already a render target and if so will dispose of it before creating a new one. Now that we have this method, we can update the constructor so that it generates the render target when a scene is created.  Update the constructor as follows"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'/// <summary>\n///     Creates a new Scene instance.\n/// </summary>\n/// <param name="game">\n///     A reference to our Game1 instance.\n/// </param>\n/// <exception cref="ArgumentNullException">\n///     Thrown if the value supplied for <paramref name="game"/> \n///     is null\n/// </exception>\npublic Scene(Game1 game)\n{\n    if (game == null)\n    {\n        throw new ArgumentNullException(nameof(game), "Game cannot be null!");\n    }\n\n    _game = game;\n    \n    //  Generate the render target\n    GenerateRenderTarget();\n}\n')),Object(i.b)("h3",{id:"handlegraphicsreset-and-handlegraphicscreated"},"HandleGraphicsReset() and HandleGraphicsCreated()"),Object(i.b)("p",null,"As was pointed out previously, whenever the graphics device is created or reset, we have to regenerate our render target instance.  So we need a couple of methods within the scene class that can be called in this events.  "),Object(i.b)("p",null,"Add the following two methods to the ",Object(i.b)("inlineCode",{parentName:"p"},"Scene")," class."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"HandleGraphicsCreated()")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"/// <summary>\n///     Handles creating the contents of VRAM for the scene when the GraphicsDevice\n///     is created.\n/// </summary>\npublic virtual void HandleGraphicsCreated()\n{\n    GenerateRenderTarget();\n}\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"HandleGraphicsReset()")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"})," /// <summary>\n///     Handles recreating contents of VRAM for the scene when the GraphicsDevice\n///     is reset.\n/// </summary>\npublic virtual void HandleGraphicsReset()\n{\n    GenerateRenderTarget();\n}\n")),Object(i.b)("h3",{id:"using-the-rendertarget"},"Using the RenderTarget"),Object(i.b)("p",null,"Now that we have a render target for the scene that we can draw too, we need to tell the scene to actually draw to it instead of to the game window directly. We can do this by telling the ",Object(i.b)("inlineCode",{parentName:"p"},"GraphicsDevice")," to use the render target.  Find the ",Object(i.b)("inlineCode",{parentName:"p"},"BeforeDraw(SpriteBatch)")," method of our ",Object(i.b)("inlineCode",{parentName:"p"},"Scene")," class and change it to the following."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'/// <summary>\n///     Handles preparing the Scene to draw.\n/// </summary>\n/// <remarks>\n///     This is called just before the main Draw method.\n/// </remarks>\n/// <param name="spriteBatch"></param>\npublic virtual void BeforeDraw(SpriteBatch spriteBatch, Color clearColor)\n{\n    //  Tell the graphics device to use this scene\'s render target.\n    _game.GraphicsDevice.SetRenderTarget(RenderTarget);\n\n    //  Clear the backbuffer\n    _game.GraphicsDevice.Clear(clearColor);\n\n    //  Begin the spritebatch\n    spriteBatch.Begin();\n}\n')),Object(i.b)("p",null,"Here, the change we made is the first line inside the method.  We simply tell the ",Object(i.b)("inlineCode",{parentName:"p"},"GraphicsDevice")," to use the scene's render target.  "),Object(i.b)("p",null,"This however is only half the story.  If we tell the ",Object(i.b)("inlineCode",{parentName:"p"},"GraphicsDevice")," to use the render target, then it will keep using it, even other draw code outside of our scene. We need to make sure that when we are finished drawing our scene, that we tell the ",Object(i.b)("inlineCode",{parentName:"p"},"GraphicsDevice")," to switch back to drawing to the backbuffer. "),Object(i.b)("p",null,"To do this, locate the ",Object(i.b)("inlineCode",{parentName:"p"},"AfterDraw(SpriteBatch)")," method, and change it to the following."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'/// <summary>\n///     Handles ending any drawing the scene is performing.\n/// </summary>\n/// <remarks>\n///     This is called immediately after Draw.\n/// </remarks>\n/// <param name="spriteBatch">\n///     The SpriteBatch instance used for rendering.\n/// </param>\npublic virtual void AfterDraw(SpriteBatch spriteBatch)\n{\n    //  End the spritebatch\n    spriteBatch.End();\n\n    //  Tell the graphics device to stop using the render target\n    _game.GraphicsDevice.SetRenderTarget(null);\n}\n')),Object(i.b)("p",null,"The change we made here is at the end of method. We just set the render target that the ",Object(i.b)("inlineCode",{parentName:"p"},"GraphicsDevice")," is using to ",Object(i.b)("inlineCode",{parentName:"p"},"null"),".  This tell it to go back to drawing to the game window."),Object(i.b)("h3",{id:"disposing-the-rendertarget"},"Disposing the RenderTarget"),Object(i.b)("p",null,"The last change we need to make to our ",Object(i.b)("inlineCode",{parentName:"p"},"Scene")," class is ensuring that we dispose of the ",Object(i.b)("inlineCode",{parentName:"p"},"RenderTarget2D")," instance when the scene is no longer being used.  If you recall from the previous tutorial, we setup the ",Object(i.b)("inlineCode",{parentName:"p"},"UnloadContent()")," method to handle freeing resources managed by the Scene's ",Object(i.b)("inlineCode",{parentName:"p"},"ContentManger()"),".  This will be a great place to also dispose of the render target, since itself is content of the scene that needs to be unloaded."),Object(i.b)("p",null,"Find the ",Object(i.b)("inlineCode",{parentName:"p"},"UpdateContent()")," method and update it to the following."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"/// <summary>\n///     Unloads any content that has been loaded by the scene.\n/// </summary>\n/// <remarks>\n///     This will be called after the game switches to a new\n///     scene.\n/// </remarks>\npublic virtual void UnloadContent()\n{\n    _content.Unload();\n    _content = null;\n\n    //  Dispose of the render target if it is not already disposed.\n    if(RenderTarget != null && !RenderTarget.IsDisposed)\n    {\n        RenderTarget.Dispose();\n        RenderTarget = null;\n    }\n}\n")),Object(i.b)("p",null,"Here the change we make is to check if the render target hasn't been disposed, and if not, we dispose of it."))}d.isMDXComponent=!0}}]);