(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{115:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return b}));var o=n(0),i=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=i.a.createContext({}),u=function(e){var t=i.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=u(e.components);return i.a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=i.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,a=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),m=u(n),d=o,b=m["".concat(a,".").concat(d)]||m[d]||p[d]||r;return n?i.a.createElement(b,l(l({ref:t},s),{},{components:n})):i.a.createElement(b,l({ref:t},s))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var s=2;s<r;s++)a[s]=n[s];return i.a.createElement.apply(null,a)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},81:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var o=n(3),i=n(7),r=(n(0),n(115)),a={id:"conclusion",title:"Collision Detection: Conclusion",hide_title:!0,hide_table_of_contents:!1,sidebar_label:"Conclusion",custom_edit_url:null,keywords:["monogame tutorial","monogame framework","monogame","tutorial","aabb collision","aabb","circle collision","collision detection","collision"],description:"A tutorial series on detecting collisions between 2D primitives in MonoGame.",image:"/img/mgb_cookie.svg",slug:"/tutorials/monogame-3-8/collision-detection/conclusion"},l={unversionedId:"tutorials/monogame-3-8/collision-detection/conclusion",id:"tutorials/monogame-3-8/collision-detection/conclusion",isDocsHomePage:!1,title:"Collision Detection: Conclusion",description:"A tutorial series on detecting collisions between 2D primitives in MonoGame.",source:"@site/docs\\tutorials\\monogame-3-8\\collision-detection\\04-conclusion.md",slug:"/tutorials/monogame-3-8/collision-detection/conclusion",permalink:"/docs/tutorials/monogame-3-8/collision-detection/conclusion",editUrl:null,version:"current",lastUpdatedBy:"Christopher Whitley",lastUpdatedAt:1609038157,sidebar_label:"Conclusion",sidebar:"tutorials",previous:{title:"Collision Detection: Circles",permalink:"/docs/tutorials/monogame-3-8/collision-detection/circles"},next:{title:"Scenes: Introduction",permalink:"/docs/tutorials/monogame-3-8/scenes/introduction"}},c=[{value:"Conclusion",id:"conclusion",children:[]}],s={rightToc:c};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"conclusion"},"Conclusion"),Object(r.b)("p",null,"In this tutorial series, we've discussed collision detection between two rectangles and between two circles. We then implemented the ideas into code into a MonoGame game project.  These two methods are foundational for 2D collision detection in any game development environment and many other implementations can be built off of them. One thing we did not discuss in this series however was collision detection between more complex polygons such as triangles, pentagons, hexagons, etc.  We also did not discuss checking collisions between a polygon and a circle.  "),Object(r.b)("p",null,"To perform these collision detections, you would most likely use what is called ",Object(r.b)("strong",{parentName:"p"},"Separating Axis Theorem"),".  The maths behind this have been discussed in length in many other tutorials far better than I could explain, so I will defer you to read those.  If you are interested in further reading about this, please see the following articles as a good starting point"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"https://www.sevenson.com.au/actionscript/sat/"}),"Separating Axis Theorem (SAT) Explanation")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169"}),"Collision Detection Using the Separating Axis Theorem")," by Kah Shiu Chong"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"http://www.metanetsoftware.com/technique/tutorialA.html"}),"N Tutorial A - Collision Detection and Response"))))}u.isMDXComponent=!0}}]);