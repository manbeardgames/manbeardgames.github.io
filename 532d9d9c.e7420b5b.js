(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{111:function(e,t,a){"use strict";a.d(t,"a",(function(){return h})),a.d(t,"b",(function(){return u}));var n=a(0),r=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function c(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=r.a.createContext({}),m=function(e){var t=r.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):c(c({},t),e)),a},h=function(e){var t=m(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=m(a),p=n,u=h["".concat(i,".").concat(p)]||h[p]||b[p]||o;return a?r.a.createElement(u,c(c({ref:t},l),{},{components:a})):r.a.createElement(u,c({ref:t},l))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=p;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:n,i[1]=c;for(var l=2;l<o;l++)i[l]=a[l];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}p.displayName="MDXCreateElement"},180:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/tutorial-cover-9709cb146fced47e00b77fbb0b3ac7b5.png"},181:function(e,t,a){"use strict";a.r(t),t.default=a.p+"assets/images/world-to-screen-space-2ab94c951bce859adc4a5e123e5757b5.png"},76:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return c})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return m}));var n=a(3),r=a(7),o=(a(0),a(111)),i={id:"tutorials-2d-camera",sidebar_label:"2D Camera",title:"2D Camera",hide_table_of_contents:!1,custom_edit_url:null,slug:"/tutorials/2d-camera"},c={unversionedId:"tutorials/tutorials-2d-camera",id:"tutorials/tutorials-2d-camera",isDocsHomePage:!1,title:"2D Camera",description:"A camera can be an essential part of your game when you need to create game worlds that expand beyond the scope of the game windows width and height. The concept of a camera can seem overwhelming at first, but here we'll layout the groundwork as simple as possible in a way that you can expand on to suite your game project's needs.",source:"@site/docs\\tutorials\\2d-camera.md",slug:"/tutorials/2d-camera",permalink:"/docs/tutorials/2d-camera",editUrl:null,version:"current",lastUpdatedBy:"Christopher Whitley",lastUpdatedAt:1608610451,sidebar_label:"2D Camera"},s=[{value:"Project Files",id:"project-files",children:[]},{value:"Create the Camera Class",id:"create-the-camera-class",children:[]},{value:"Updating the Matrices",id:"updating-the-matrices",children:[]},{value:"Adding Camera Properties",id:"adding-camera-properties",children:[]},{value:"Screen Space to Camera Space Methods",id:"screen-space-to-camera-space-methods",children:[]},{value:"Using the Camera",id:"using-the-camera",children:[]}],l={rightToc:s};function m(e){var t=e.components,i=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,i,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"A camera can be an essential part of your game when you need to create game worlds that expand beyond the scope of the game windows width and height. The concept of a camera can seem overwhelming at first, but here we'll layout the groundwork as simple as possible in a way that you can expand on to suite your game project's needs."),Object(o.b)("p",null,"Creating a camera will require the use of vectors math and matrices math to create a Transformation Matrix. It is beyond the scope of these tutorials to explain the math behind it. If you would like to further research this topic, the article ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.alanzucconi.com/2016/02/10/tranfsormation-matrix/#part1"}),"The Transform Matrix For 2D Games")," is a good starting place. "),Object(o.b)("h2",{id:"project-files"},"Project Files"),Object(o.b)("p",null,"If you would like to follow along with this tutorial using the same files and assets I use, you can find them here on github."),Object(o.b)("h2",{id:"create-the-camera-class"},"Create the Camera Class"),Object(o.b)("p",null,"If you are unfamiliar with the concept of a camera in game development, it is gives us something called a Transformation Matrix, which we can then apply to our rendering. This transformation matrix contains the information to translate, rotate, and scale what we tell to render so that it looks as if we're viewing the game from the perspective of the camera. "),Object(o.b)("p",null,Object(o.b)("img",{src:a(180).default})),Object(o.b)("p",null,"To get started, create a new class for your camera, I'll call mine ",Object(o.b)("inlineCode",{parentName:"p"},"Camera2D"),". Add the following:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-csharp"}),'public class Camera2D\n{\n    //  The transformation matrix of the camera\n    private Matrix _transformationMatrix = Matrix.Identity;\n\n    //  The inverse of the transformation matrix\n    private Matrix _inverseMatrix = Matrix.Identity;\n\n    //  The xy-coordinate top-left position of the camera\n    private Vector2 _position = Vector2.Zero;\n\n    //  The rotation of the camera along the Z axis\n    private float _rotation = 0;\n\n    //  The x and y zoom level of the camera\n    private Vector2 _zoom = Vector2.One;\n\n    //  The xy-coordinate origin point of the camera\n    private Vector2 _origin = Vector2.Zero;\n\n    //  Has the position, angle, origin, or zoom of the camera changed\n    private bool _hasChanged;\n\n    //  The Viewport reference for the camera\n    public Viewport Viewport;\n\n    /// <summary>\n    ///     Creates a new 2D camera instance\n    /// </summary>\n    /// <param name="viewPort">The Viewport reference for the camera</param>\n    public Camera2D(Viewport viewPort)\n    {\n        Viewport = viewPort;\n    }\n\n    /// <summary>\n    ///     Creates a new 2D camera instance\n    /// </summary>\n    /// <param name="width">The width of the viewport</param>\n    /// <param name="height">The height of the viewport</param>\n    public Camera2D(int width, int height)\n    {\n        Viewport = new Viewport();\n        Viewport.Width = width;\n        Viewport.Height = height;\n    }\n\n}\n')),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Field"),Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Type"),Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Description"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"_transformationMatrix"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"Matrix")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This is the matrix that we will calculate in a minute that includes our translation, rotation, and scale information. This will be used by the ",Object(o.b)("inlineCode",{parentName:"td"},"SpriteBatch")," when we perform our rendering.")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"_inverseMatrix"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"Matrix")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This is the inverse of our transformation matrix.")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"_position"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"Vector2")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This is the xy-coordinate position of our camera relative to the top-left of the camera's view. In terms of our transformation matrix, this is the ",Object(o.b)("strong",{parentName:"td"},"translation"),".")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"_rotation"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"float")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This is the angle of rotation for our camera. In terms of our transformation matrix, this is the ",Object(o.b)("strong",{parentName:"td"},"rotation"),".")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"_zoom"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"Vector2")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This is the zoom level of the camera. In terms of our transformation matrix, this is the ",Object(o.b)("strong",{parentName:"td"},"scale"),".")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"_origin"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"Vector2")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This is the origin point of our camera. By default, it is Vector2.Zero, which means our camera's origin is the top-left.")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"_hasChanged"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"bool")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This is a boolean value we'll set to true anytime either the position, rotation, or scale of the camera has changed, signifying that we need to update our transformation matrix.")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"ViewPort"),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"ViewPort")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"This is the Viewport reference for our camera.")))),Object(o.b)("p",null,"After the fields are declared, two constructors are introduced. The first constructor allows us to pass in a reference to an existing ",Object(o.b)("inlineCode",{parentName:"p"},"ViewPort"),". This is useful because it allows us to use the Viewport from our Game1 class provided by default by MonoGame. The second constructor allows use to supply a width and height, which will create a viewport reference for use base on these dimensions."),Object(o.b)("h2",{id:"updating-the-matrices"},"Updating the Matrices"),Object(o.b)("p",null,"To keep our transformation matrix and inverse matrix updated, we'll create a method called ",Object(o.b)("inlineCode",{parentName:"p"},"UpdateMatrices"),". Calculating a new transformation matrix is done through the multiplication of a translation matrix of our ",Object(o.b)("inlineCode",{parentName:"p"},"_position"),", a rotation matrix of our ",Object(o.b)("inlineCode",{parentName:"p"},"_rotation"),", a scale matrix of our ",Object(o.b)("inlineCode",{parentName:"p"},"_zoom"),", and an additional translation matrix of our ",Object(o.b)("inlineCode",{parentName:"p"},"_origin"),". Once we have each of these individual matrices, we can multiply them all together to get our final ",Object(o.b)("inlineCode",{parentName:"p"},"_transformationMatrix"),". Then to get the value of our ",Object(o.b)("inlineCode",{parentName:"p"},"_inverseMatrix"),", we just inverse the transformation matrix."),Object(o.b)("p",null,"Add the following method to our Camera2D class"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-csharp"}),"/// <summary>\n///     Updates the values for our transformation matrix and \n///     the inverse matrix.  \n/// </summary>\nprivate void UpdateMatrices()\n{\n\n    //  Create a translation matrix based on the position of the camera\n    var positionTranslationMatrix = Matrix.CreateTranslation(new Vector3()\n    {\n        X = -(int)Math.Floor(_position.X),\n        Y = -(int)Math.Floor(_position.Y),\n        Z = 0\n    });\n\n    //  Create a rotation matrix around the Z axis\n    var rotationMatrix = Matrix.CreateRotationZ(_rotation);\n\n    //  Create a scale matrix based on the zoom\n    var scaleMatrix = Matrix.CreateScale(new Vector3()\n    {\n        X = _zoom.X,\n        Y = _zoom.Y,\n        Z = 1\n    });\n\n    //  Create a translation matrix based on the origin position of the camera\n    var originTranslationMatrix = Matrix.CreateTranslation(new Vector3()\n    {\n        X = (int)Math.Floor(_origin.X),\n        Y = (int)Math.Floor(_origin.Y),\n        Z = 0\n    });\n\n    //  Perform matrix multiplication of all of the above to create our\n    //  transformation matrix\n    _transformationMatrix = positionTranslationMatrix * rotationMatrix * scaleMatrix * originTranslationMatrix;\n\n    //  Get our inverse matrix of the transformation matrix\n    _inverseMatrix = Matrix.Invert(_transformationMatrix);\n\n    //  Since the matrices have now been updated, set that there is no longer a change\n    _hasChanged = false;\n    \n}\n")),Object(o.b)("p",null,"And that's it for the hard stuff.  This will keep the transformation and inverse matrix values updated whenever there is a change to the position, rotation, or scale.  Next, we'll create the public properties that can be used to retrieve the values needed from the camera to use within the game."),Object(o.b)("h2",{id:"adding-camera-properties"},"Adding Camera Properties"),Object(o.b)("hr",null),Object(o.b)("p",null,"The first two properties that we are going to add are for the TransformationMatrix and the InverseMatrix.  Add the following to the Camera2D class."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-csharp"}),"/// <summary>\n///     Gets the cameras transformation matrix\n/// </summary>\npublic Matrix TransformationMatrix\n{\n    get\n    {\n        //  If a change is detected, update matrices before\n        //  returning value\n        if(_hasChanged)\n        {\n            UpdateMatrices();\n        }\n        return _transformationMatrix;\n    }\n}\n\n/// <summary>\n///     Gets the inverse of the camera's transformation matrix\n/// </summary>\npublic Matrix InverseMatrix\n{\n    get\n    {\n        //  If a change is detected, update matrices before\n        //  returning value\n        if (_hasChanged)\n        {\n            UpdateMatrices();\n        }\n        return _inverseMatrix;\n    }\n}\n")),Object(o.b)("p",null,"Both of these just return their respective backing fields, however, before returning, they check if the ",Object(o.b)("inlineCode",{parentName:"p"},"_hasChanged")," boolean is true.  If it is, a call to update our matrices is performed first before returning the values. Next we'll add a few additional properties that will allow the adjustment of the camera's position, rotation, scale, and origin.  Add the following to the Camera2D class:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-csharp"}),"/// <summary>\n///     Gets or Sets the xy-coordinate position of the camera relative\n///     to the world space of the game\n/// </summary>\npublic Vector2 Position\n{\n    get { return _position; }\n    set\n    {\n        //  If the value hasn't actually changed, just return back\n        if (_position == value) { return; }\n\n        //  Set the position value\n        _position = value;\n\n        //  Flag that a change has been made\n        _hasChanged = true;\n    }\n}\n\n/// <summary>\n///     Gets or Sets the rotation angle of the camera\n/// </summary>\npublic float Rotation\n{\n    get { return _rotation; }\n    set\n    {\n        //  If the value hasn't actually changed, just return back\n        if (_rotation == value) { return; }\n\n        //  Set the rotation value\n        _rotation = value;\n\n        //  Flag that a change has been made\n        _hasChanged = true;\n    }\n}\n\n/// <summary>\n///     Gets or Sets the zoom level of the camera\n/// </summary>\npublic Vector2 Zoom\n{\n    get { return _zoom; }\n    set\n    {\n        //  If the value hasn't actually changed, just return back\n        if (_zoom == value) { return; }\n\n        //  Set the zoom value\n        _zoom = value;\n\n        //  Flag that a change has been made\n        _hasChanged = true;\n    }\n}\n\n/// <summary>\n///     Gets or Sets the origin point of the camera relative to the\n///     ViewPort\n/// </summary>\npublic Vector2 Origin\n{\n    get { return _origin; }\n    set\n    {\n        //  If the value hasn't actually changed, just return back\n        if (_origin == value) { return; }\n\n        //  Set the origin value\n        _origin = value;\n\n        //  Flag that a change has been made\n        _hasChanged = true;\n    }\n}\n\n/// <summary>\n///     Gets or Sets the camera's x-coordinate position relative to the world\n///     space of the game\n/// </summary>\npublic float X\n{\n    get { return _position.X; }\n    set\n    {\n        //  If the value hasn't actually changed, just return back\n        if (_position.X == value) { return; }\n\n        //  Set the position x value\n        _position.X = value;\n\n        //  Flag that a change has been made\n        _hasChanged = true;\n    }\n}\n\n/// <summary>\n///     Gets or Sets the camera's y-coordinate position relative to the world\n///     space of the game\n/// </summary>\npublic float Y\n{\n    get { return _position.Y; }\n    set\n    {\n        //  If the value hasn't actually changed, just return back\n        if (_position.Y == value) { return; }\n\n        //  Set the position y value\n        _position.Y = value;\n\n        //  Flag that a change has been made\n        _hasChanged = true;\n    }\n}\n")),Object(o.b)("p",null,"The getter for each of these properties return back their respective backing field values.  In each of the setters, first a check to see if the value has actually changed is performed.  If it is actually a new value, the value is set to the respective backing field, and the ",Object(o.b)("inlineCode",{parentName:"p"},"_hasChanged")," boolean is set to true, indicating that a change has been made.  The last two properties ",Object(o.b)("inlineCode",{parentName:"p"},"X")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Y")," are mostly there for utility so we can set them individually instead of having to supply a full Vector2 each time to ",Object(o.b)("inlineCode",{parentName:"p"},"Position"),".  "),Object(o.b)("p",null,"That's it for our properties.  "),Object(o.b)("h2",{id:"screen-space-to-camera-space-methods"},"Screen Space to Camera Space Methods"),Object(o.b)("hr",null),Object(o.b)("p",null,"By introducing a camera into our game, we've also created two separate coordinate spaces.  "),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"System"),Object(o.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"Definition"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("strong",{parentName:"td"},"World Space")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The World Space coordinate system defines the xy-coordinate location of the entities within our game's world.")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(o.b)("strong",{parentName:"td"},"Screen Space")),Object(o.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"The screen space coordinate system defines the xy-coordinate location relative to the game's window, with the top-left of the game window being xy-positiong {0, 0}.  This is the coordinate system things outside of our game, such as the players mouse, exist in.")))),Object(o.b)("p",null,"To further expand on this concept, take a look at the following image:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"world space to screen space concept",src:a(181).default})),Object(o.b)("p",null,"On the left is our game world.  The game world is 2000px wide by 2000px tall.  In this game world, our player is located at world space xy-position {1000, 900}.  On the right is our game screen that is being rendered.  The game screen is only 1280px wide by 720px tall.  We have the mouse at screen space xy-position {1000, 650}."),Object(o.b)("p",null,"We need something that is going to translate between these two coordinate systems. Thankfully, it's actually not too difficult.  In our Camera2D class, add the following two methods"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-csharp"}),'/// <summary>\n///     Translate the given screen space xy-coordinate position\n///     to the equivalent world space xy-coordinate position\n/// </summary>\n/// <param name="position">The xy-coordinate position in screen space to translate</param>\n/// <returns>\n///     The xy-coodinate position in world space\n/// </returns>\npublic Vector2 ScreenToWorld(Vector2 position)\n{\n    return Vector2.Transform(position, InverseMatrix);\n}\n\n/// <summary>\n///     Translates the given world space xy-coordinate position\n///     to the equivalent screen space xy-coordinate position\n/// </summary>\n/// <param name="position">The xy-coordinate position in world space to translate</param>\n/// <returns>\n///     The xy-coordinate position in screen space\n/// </returns>\npublic Vector2 WorldToScreen(Vector2 position)\n{\n    return Vector2.Transform(position, TransformationMatrix);\n}\n')),Object(o.b)("p",null,"With these two methods, we can translate between the two coordinate systems.  "),Object(o.b)("h2",{id:"using-the-camera"},"Using the Camera"),Object(o.b)("hr",null),Object(o.b)("p",null,"To use our camera in our game, first we need to create a new instance of the camera.  in our Game1 class and the following field and initialize it within the constructor."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-csharp"}),'//  Our camera\nCamera2D _camera;\n\npublic Game1()\n{\n    graphics = new GraphicsDeviceManager(this);\n    Content.RootDirectory = "Content";\n\n    \n    //  Create our camera with 1280 with and 720 height\n    _camera = new Camera2D(1280, 720);\n}\n')),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"}," If you would like to instead create the camera using the ",Object(o.b)("inlineCode",{parentName:"p"},"GraphicsDevice.ViewPort")," from within Game1, you can do this, but you'll need to create the camera instead in the ",Object(o.b)("inlineCode",{parentName:"p"},"Initialize()")," method.  This is because you need the ",Object(o.b)("inlineCode",{parentName:"p"},"GraphicsDevice")," property to be set, which it will not be until Initialize is called."))),Object(o.b)("p",null,"Now, in our ",Object(o.b)("inlineCode",{parentName:"p"},"Draw()")," method, we need to pass the transformation matrix from the camera into the spritebatch when we call ",Object(o.b)("inlineCode",{parentName:"p"},"sprtiebatch.Begin()")," like so"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-csharp"}),"spriteBatch.Begin(transformMatrix: _camera.TransformationMatrix);\n\n//  Draw things here\n\nspriteBatch.End();\n")),Object(o.b)("p",null,"And that's it.  You now have a 2D camera that you can use in you game projects.  Don't stop here though, get creative. Think of some other things to add to your camera, like a way to smoothly move it from one position to another, or a way to \"shake\" it to give that sweet sweet screen shake effect. If you have some interesting things you added, let me know on ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.twitter.com/manbeardgames"}),"Twitter")," and I'll add them here (with your permission of course). "),Object(o.b)("p",null,"And be sure to check out the project files for this tutorial on ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/manbeardgames/manbeardgames-site-tutorials/tree/master/tutorials/2d-camera"}),"Github")," for to see a completed example of using the camera and moving it around with the keyboard."))}m.isMDXComponent=!0}}]);